
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "python-blog/001-numerical-integration.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_python-blog_001-numerical-integration.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_python-blog_001-numerical-integration.py:


Numerical Integration
---------------------

Here is an introduction to Numerical Integration with Python!

.. GENERATED FROM PYTHON SOURCE LINES 7-11

.. code-block:: default

    import numpy as np
    import matplotlib.pyplot as plt
    import matplotlib as mpl








.. GENERATED FROM PYTHON SOURCE LINES 12-29

Let's look at a simple function:

.. math::

    g(x) = \sin(x)

which we know the analytical integral as:

.. math::

    G(x) = - \cos(x)

and let's integrate that from 0 to :math:`\frac{5\pi}{4}`. Analytically, this is:

.. math::

    \int_0^{\frac{5\pi}{4}} g(x) \, dx = - \cos(x) |_0^{\frac{5\pi}{4}} = - \cos(\frac{5\pi}{4}) + \cos(0) = \frac{\sqrt{2}}{2} + 1 = 1.7071

.. GENERATED FROM PYTHON SOURCE LINES 29-32

.. code-block:: default


    np.sqrt(2)/2 + 1





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    1.7071067811865475



.. GENERATED FROM PYTHON SOURCE LINES 33-42

We can visualize this as the area under the curve - which is all a numerical
integral is; an approximation of the area under the curve.
To do a numerical integration, we simply discretize our x space and then
evaluate our function. Once we have that, we can sum the evaluation and
multiply by the discretization factor to yield the effective area under the
curve.

So let's discretize :math:`g(x)` into several rectangles which we can use to
solve for the area under this curve.

.. GENERATED FROM PYTHON SOURCE LINES 42-79

.. code-block:: default



    g = lambda x: np.sin(x)
    a, b = 0, 5*np.pi/4

    y = np.linspace(a, b)

    dy = np.pi/16
    yy = np.arange(a, b, dy)

    def plot_rects(xx, f, delta):
        for v in xx:
            value = f(v)
            if value >= 0.0:
                loc = 0.0
                h = value
            else:
                loc = value
                h = 0 - value
            r = mpl.patches.Rectangle((v-delta/2., loc),
                                      width=delta, height=h,
                                      edgecolor="k", linewidth=1)
            plt.gca().add_patch(r)
        return

    def plot_g():
        plt.plot(y, g(y))
        plt.plot(yy, g(yy), "ro")

        plot_rects(yy, g, dy)

        plt.xlabel("$x$")
        plt.ylabel("$g(x)$")

    plot_g()
    plt.show()




.. image:: /python-blog/images/sphx_glr_001-numerical-integration_001.png
    :alt: 001 numerical integration
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 80-82

So now we can sum the areas of all of those rectangles to get an
approximation of the area under the curve (the integral)

.. GENERATED FROM PYTHON SOURCE LINES 82-109

.. code-block:: default

    np.sum(g(yy-(dy/2)) * dy)


    # That's not too bad considering our rectangles do not perfectly follow the
    # curve. Let's now try choosing a :math:`\Delta x` value that will increase the
    # sampling creating finer spaced rectangles to improve our approximation.

    dy = np.pi/32
    yy = np.arange(a, b, dy)

    plt.figure(figsize=(12,4))
    plt.subplot(1,2,1)
    plot_g()
    plt.title("Area = {:.3f}".format(np.sum(g(yy) * dy)))

    plt.subplot(1,2,2)

    dy = np.pi/128
    yy = np.arange(a, b, dy)

    plot_g()
    plt.title("Area = {:.3f}".format(np.sum(g(yy) * dy)))

    plt.tight_layout()
    plt.show()





.. image:: /python-blog/images/sphx_glr_001-numerical-integration_002.png
    :alt: Area = 1.740, Area = 1.716
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 110-113

.. code-block:: default


    np.sum(g(yy) * dy)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    1.7156985903219493



.. GENERATED FROM PYTHON SOURCE LINES 114-131

Now that's much better! as we decrease the :math:`\Delta x` value, we see the
apprximationm start to converge on the analtical answer for the integral.
The rectangles appear to be consistently overestimating the integral.

Integrating a Complex Function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now let's apply that concept to numerically integrate a more complex function
such as:

.. math::

    f(x) = \sin(\frac{1}{x})

from 0 to :math:`2\pi`. This allows us to really showcase where numerical
integration benefits as I don't even know where to begin when it comes to
analytically integrating that.

.. GENERATED FROM PYTHON SOURCE LINES 131-134

.. code-block:: default


    f = lambda x: np.sin(1/x)








.. GENERATED FROM PYTHON SOURCE LINES 135-142

To do so, we'll need to define a range of x values on which to evaluate the
function. Let's try out a few different sets of x values to plot the values
of :math:`f(x)` to gain insight into how this function behaves.

First, let's see what happens when we plot this function at linear intervals
between 0 and :math:`2\pi` (note that we cannont have a division by zero, so our
lower boound must be some small value, not 0: we'll use :math:`10^{-9}`.

.. GENERATED FROM PYTHON SOURCE LINES 142-155

.. code-block:: default


    num = 100000
    zero = 1e-9

    # Create an array of x values to evaluate
    x = np.linspace(zero, 2*np.pi, num)

    # Evaluate and plot the values
    plt.plot(x, f(x))
    plt.xlabel("$x$")
    plt.ylabel("$f(x)$")
    plt.show()




.. image:: /python-blog/images/sphx_glr_001-numerical-integration_003.png
    :alt: 001 numerical integration
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 156-165

Huh, that's weird. The function behaves quite different from a typical :math:`\sin`
function and we appear to see some sort of decay - let's look into that a bit
more. *At what x value are we seeing a change from oscillatory behavior to
a decay?*

From visual inspection, it looks like some value above :math:`\frac{1}{\pi}`
(0.318). Let's reevaluate the function from that x value onward.
Then find the maximum and see what interval of :math:`\pi` is causing the change
in behavior.

.. GENERATED FROM PYTHON SOURCE LINES 165-169

.. code-block:: default


    subset = np.linspace(0.3, 2*np.pi, num)
    subset[np.argmax(f(subset))] * np.pi





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    1.9999924576268395



.. GENERATED FROM PYTHON SOURCE LINES 170-172

Aha! It appears that the x value of :math:`\frac{2}{\pi}` marks the start of
decay. This makes sense because :math:`\sin(1/2/\pi) = \sin(\pi/2) = 1`

.. GENERATED FROM PYTHON SOURCE LINES 172-180

.. code-block:: default


    plt.plot(x, f(x), label="$f(x)$")
    plt.plot(2./np.pi, f(2./np.pi), 'ro', label=r"$x=\frac{2}{\pi}$")
    plt.legend()
    plt.xlabel("$x$")
    plt.ylabel("$f(x)$")
    plt.show()




.. image:: /python-blog/images/sphx_glr_001-numerical-integration_004.png
    :alt: 001 numerical integration
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 181-190

So now we know that have a speration point in our function - this might come
in handy later. as we may have to treat those two regions of the function
separately when numerically integrating.

Now, let's explore the jumbled up portion of the plot for very low x values.
There appears to be some high frequency oscillation between -1 and 1, but we
can't really tell. To do this, let's create an exponentially varying x
space to evaluate our function which will bring out finer sampling for lower
values and see how the function behaves as x approaches zero.

.. GENERATED FROM PYTHON SOURCE LINES 190-199

.. code-block:: default


    x = np.geomspace(1e-2, 2*np.pi, num)

    plt.plot(x, f(x))
    plt.gca().set_xscale('log')
    plt.xlabel("$x$")
    plt.ylabel("$f(x)$")
    plt.show()




.. image:: /python-blog/images/sphx_glr_001-numerical-integration_005.png
    :alt: 001 numerical integration
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 200-214

Now that's cool! :math:`f(x)` appears to have increasing frequency as x
approaches zero. This is quite different from a normal :math:`\sin` function where
we don't see any frequency change at all. This frequency variation will
definitely pose a challenge for our numerical integration as we will need to
make sure we properly sample this signal without aliasing.

Let's see if we can come up with an equation for capturing that frequency
variation as something we can use to build out our values that we will use
for the numerical integration.

First, let's evaluate our function between integer changes in :math:`\pi` to see
how :math:`f(x)` oscilates between -1 and 1. We know from above that the last
value of 1 occurred at :math:`\frac{2}{\pi}`, so let's use decreasing values from
there.

.. GENERATED FROM PYTHON SOURCE LINES 214-218

.. code-block:: default


    f(3./np.pi)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    0.8660254037844386



.. GENERATED FROM PYTHON SOURCE LINES 219-222

.. code-block:: default

    f(3./(2.*np.pi))






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    0.8660254037844387



.. GENERATED FROM PYTHON SOURCE LINES 223-226

.. code-block:: default

    f(2./(3*np.pi))






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    -1.0



.. GENERATED FROM PYTHON SOURCE LINES 227-230

.. code-block:: default

    f(2./(4*np.pi))






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    -2.4492935982947064e-16



.. GENERATED FROM PYTHON SOURCE LINES 231-233

.. code-block:: default

    f(2./(5*np.pi))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    1.0



.. GENERATED FROM PYTHON SOURCE LINES 234-236

So this is interesting. I'm seeing a weird pattern where :math:`\frac{2}{n \pi}`
appears to oscillate :math:`f(x)` between -1 and 1. Let's test this out.

.. GENERATED FROM PYTHON SOURCE LINES 236-250

.. code-block:: default


    xx = lambda n: 2/(n*np.pi)
    nn = 65
    n = np.arange(1, nn)
    xn = xx(n)

    plt.plot(xn, f(xn), "ro")
    plt.plot(x, f(x))
    plt.gca().set_xscale('log')
    plt.xlabel("$x$")
    plt.ylabel("$f(x)$")
    plt.show()





.. image:: /python-blog/images/sphx_glr_001-numerical-integration_006.png
    :alt: 001 numerical integration
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 251-262

It appears that the equation :math:`\frac{2}{n \pi}` captures the oscilatory
behavior of :math:`f(x)` quite well! We see that it marks the minimums, maximums,
and zero-cross points for every period of :math:`f(x)`. This is just what we need
to effectively integrate :math:`f(x)`.

To start integrating this function, we simply need to sample several times
between values of :math:`n`. Doing so is as simple as bumping up the number of
setting a step size in ``numpy``'s ``arange`` method. Let's use a step size of
0.25 as that will give us 4 values between each cross-over and the min/max
point. Let's see if that gives us a visually pleasing approximation of our
function.

.. GENERATED FROM PYTHON SOURCE LINES 262-288

.. code-block:: default


    def plot_f():
        plt.gca().set_xscale('log')
        plt.plot(x, f(x))
        plt.plot(xn, f(xn), "ro")

        for i, v in enumerate(xn):
            if i == len(xn)-1:
                continue
            value = f(v)
            if value >= 0.0:
                loc = 0.0
                h = value
            else:
                loc = value
                h = 0 - value
            delta = abs(xn[i] - xn[i+1])
            r = mpl.patches.Rectangle((v - delta/2, loc),
                                      width=delta, height=h,
                                      edgecolor="k", linewidth=1)
            plt.gca().add_patch(r)
        plt.xlabel("$x$")
        plt.ylabel("$f(x)$")
        return









.. GENERATED FROM PYTHON SOURCE LINES 289-297

.. code-block:: default


    dx = 0.25
    n = np.arange(1, nn, step=dx)
    xn = xx(n)

    plot_f()
    plt.show()




.. image:: /python-blog/images/sphx_glr_001-numerical-integration_007.png
    :alt: 001 numerical integration
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 298-300

That looks decent, but I think we can do better. Let's try 0.1 for 10 samples
between the cross overs and the min/max

.. GENERATED FROM PYTHON SOURCE LINES 300-310

.. code-block:: default


    dn = 0.1
    # 1/np.pi**2
    n = np.arange(1, nn, step=dn)
    xn = xx(n)

    plot_f()
    plt.show()





.. image:: /python-blog/images/sphx_glr_001-numerical-integration_008.png
    :alt: 001 numerical integration
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 311-316

Now that looks pretty darn good! How about we try integrating :math:`f(x)` now!
To do so, we simply take our values and multiply by the :math:`\Delta x` value
(the rectangle widths). It's important to note here that :math:`\Delta x` is not a
constant this time, so well need to compute an array of all of our
:math:`\Delta x` values first.

.. GENERATED FROM PYTHON SOURCE LINES 316-322

.. code-block:: default


    dx = np.pi/(128*4)
    x = np.arange(2/np.pi, 2*np.pi, step=dx)
    right = np.sum(f(x) * dx)
    right





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    2.1014656967879217



.. GENERATED FROM PYTHON SOURCE LINES 323-325

The right side there is pretty good
(`check with wolfram alpha <https://www.wolframalpha.com/input/?i=integrate+sin+1%2Fx+dx+from+x%3D2%2Fpi+to+2pi>`_)

.. GENERATED FROM PYTHON SOURCE LINES 325-336

.. code-block:: default



    def compute_left(dn, nn=1000):
        n = np.arange(1, nn, step=dn)
        xn = xx(n)
        dx = np.abs(np.diff(xn))
        return np.sum(f(xn)[:-1] * dx)

    left = compute_left(dn)
    left





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    0.17968499172741753



.. GENERATED FROM PYTHON SOURCE LINES 337-340

Well that's not very good as we know the true value for the left side to be
0.164619 `from Wolfram Alpha <https://www.wolframalpha.com/input/?i=integrate+sin+1%2Fx+dx+from+x%3D0+to+2%2Fpi+>`_.
Let's see if incresing the discretization helps.

.. GENERATED FROM PYTHON SOURCE LINES 340-346

.. code-block:: default



    left = compute_left(0.0001)
    left






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    0.16463442561346053



.. GENERATED FROM PYTHON SOURCE LINES 347-349

.. code-block:: default

    left+right





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    2.266100122401382



.. GENERATED FROM PYTHON SOURCE LINES 350-355

The full integral is known to be 2.26277 from `Wolfram Alpha <https://www.wolframalpha.com/input/?i=integrate+sin+1%2Fx+dx+from+x%3D0+to+2pi>`_
so that's not too bad of an approximation!

And there you have it! The integral of :math:`\sin(\frac{1}{x})` has been
numerically integrated!


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  3.345 seconds)


.. _sphx_glr_download_python-blog_001-numerical-integration.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: 001-numerical-integration.py <001-numerical-integration.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: 001-numerical-integration.ipynb <001-numerical-integration.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
